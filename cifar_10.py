# -*- coding: utf-8 -*-
"""CIFAR-10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Mesn9JbTbHrZ5DHQwllLds3nSM4v4X-L
"""

import numpy as np
import torch
import torch.nn as nn
import torchvision.datasets as dataset
import torchvision.transforms as transform
from torch.utils.data import DataLoader

cifar10_train = dataset.CIFAR10(root="./dataset/",
                                train=True,
                                transform=transform.ToTensor(),
                                download=True)

cifar10_test = dataset.CIFAR10(root="./dataset/",
                             train=False,
                             transform=transform.ToTensor(),
                             download=True)

classes=("plane","car","bird","cat","deer","dog","frog","horse","ship","truck")

class LeNet5(nn.Module):
  def __init__(self):
    super(LeNet5, self).__init__()
    self.conv1 = nn.Conv2d(in_channels=3, out_channels=6, kernel_size=5)
    self.conv2 = nn.Conv2d(in_channels=6, out_channels=16, kernel_size=5)
    self.fc1=nn.Linear(in_features=400, out_features=120)
    self.fc2=nn.Linear(in_features=120, out_features=84)
    self.fc3 = nn.Linear(in_features=84, out_features=10)
    self.relu = nn.ReLU()
    self.maxPool2d = nn.MaxPool2d(kernel_size=2, stride=2)

  def forward(self,x):
    out = self.relu(self.conv1(x))
    out = self.maxPool2d(out)
    out = self.relu(self.conv2(out))
    out = self.maxPool2d(out)
    out = out.view(-1,400)
    out = self.relu(self.fc1(out))
    out = self.relu(self.fc2(out))
    out = self.fc3(out)
    return out

batch_size = 100
learning_rate=0.1
training_epochs = 15
loss_function = nn.CrossEntropyLoss()
network = LeNet5()
optimizer = torch.optim.SGD(network.parameters(), lr = learning_rate)

data_loader =DataLoader(dataset=cifar10_train,
                       batch_size = batch_size,
                       shuffle=True,
                       drop_last=True)

for epoch in range(training_epochs):
  avg_cost = 0
  total_batch = len(data_loader)

  for img, label in data_loader:
    pred = network(img)
    loss=loss_function(pred, label)
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()

    
    avg_cost +=loss/total_batch
  print("Epoch:%d Loss =%f"%(epoch+1, avg_cost))
torch.save(network.state_dict(),"./mlp_mnist.pth")
print("Learning finished")

with torch.no_grad():
  img_test = torch.tensor(np.transpose(cifar10_test.data,(0,3,1,2)))/255.
  label_test = torch.tensor(cifar10_test.targets)

  prediction = network(img_test)
  correct_prediction = torch.argmax(prediction,1)==label_test
  accuracy = correct_prediction.float().mean()
  print("Accuracy:", accuracy.item())

correct_counts = np.zeros(10)
for idx in range(cifar10_test.__len__()):
  if correct_prediction[idx]:
    correct_counts[label_test[idx]]+=1
accuracy_each_class=correct_counts/(cifar10_test.__len__()/10)

for idx in range(10):
  print("Accuracy for %s\t:%f"%(classes[idx],accuracy_each_class[idx]))

import torch
from torchvision import models
from torchsummary import summary
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
vgg = models.vgg16().to(device)

summary(vgg, (3,244,244))

from torchsummary import summary
summary(network.to(device),(3,32,32))