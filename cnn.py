# -*- coding: utf-8 -*-
"""CNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18GspZcSdSFovyG8qRe-BvdTj6AYvAsQf
"""

import torch
import torch.nn as nn
import torchvision.datasets as dataset
import torchvision.transforms as transform
from torch.utils.data import DataLoader

mnist_train = dataset.MNIST(root="./dataset/",
                           train=True,
                           transform=transform.ToTensor(),
                           download=True)

mnist_test = dataset.MNIST(root="./dataset/",
                          train=False,
                          transform=transform.ToTensor(),
                          download=True)

class LeNet5(nn.Module):
  def __init__(self):
    super(LeNet5, self).__init__()
    self.conv1 = nn.Conv2d(in_channels=1, out_channels=6, kernel_size=5)
    self.conv2 = nn.Conv2d(in_channels=6, out_channels=16, kernel_size=5)
    self.fc1=nn.Linear(in_features=256, out_features=120)
    self.fc2=nn.Linear(in_features=120, out_features=84)
    self.fc3 = nn.Linear(in_features=84, out_features=10)
    self.relu = nn.ReLU()
    self.maxPool2d = nn.MaxPool2d(kernel_size=2, stride=2)

  def forward(self,x):
    out = self.relu(self.conv1(x))
    out = self.maxPool2d(out)
    out = self.relu(self.conv2(out))
    out = self.maxPool2d(out)
    out = out.view(-1,256)
    out = self.relu(self.fc1(out))
    out = self.relu(self.fc2(out))
    out = self.fc3(out)
    return out

batch_size = 100
learning_rate=0.1
training_epochs = 15
loss_function = nn.CrossEntropyLoss()
network = LeNet5()
optimizer = torch.optim.SGD(network.parameters(), lr = learning_rate)

data_loader =DataLoader(dataset=mnist_train,
                       batch_size = batch_size,
                       shuffle=True,
                       drop_last=True)

for epoch in range(training_epochs):
  avg_cost = 0
  total_batch = len(data_loader)

  for img, label in data_loader:
    pred = network(img)
    loss=loss_function(pred, label)
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()

    img = img.view(-1,28*28)
    avg_cost +=loss/total_batch
  print("Epoch:%d Loss =%f"%(epoch+1, avg_cost))
torch.save(network.state_dict(),"./mlp_mnist.pth")
print("Learning finished")

with torch.no_grad():
  img_test = mnist_test.data.unsqueeze(1).float()
  label_test = mnist_test.targets

  prediction = network(img_test)
  correct_prediction = torch.argmax(prediction,1)==label_test
  accuracy = correct_prediction.float().mean()
  print("Accuracy:", accuracy.item())

